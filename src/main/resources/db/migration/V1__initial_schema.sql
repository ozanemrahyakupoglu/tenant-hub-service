-- =============================================================
-- TenantHub Initial Schema
-- =============================================================

-- ---------------------------------------------------------------
-- USER
-- ---------------------------------------------------------------
CREATE SEQUENCE SEQ_USER START WITH 1 INCREMENT BY 1;

CREATE TABLE "USER" (
    ID                  BIGINT          NOT NULL DEFAULT nextval('SEQ_USER'),
    USERNAME            VARCHAR(100)    NOT NULL,
    EMAIL               VARCHAR(150)    NOT NULL,
    PASSWORD_HASH       VARCHAR(255)    NOT NULL,
    FIRST_NAME          VARCHAR(100)    NOT NULL,
    LAST_NAME           VARCHAR(100)    NOT NULL,
    PHONE               VARCHAR(20),
    STATUS              VARCHAR(20)     NOT NULL DEFAULT 'ACTIVE',
    LAST_LOGIN_DATE     TIMESTAMP,
    ERROR_LOGIN_COUNT   INTEGER         NOT NULL DEFAULT 0,
    CREATED_BY          VARCHAR(100)    NOT NULL,
    CREATED_DATE        TIMESTAMP       NOT NULL,
    CREATED_IP          VARCHAR(45)     NOT NULL,
    UPDATED_BY          VARCHAR(100),
    UPDATED_DATE        TIMESTAMP,
    UPDATED_IP          VARCHAR(45),
    CONSTRAINT PK_USER          PRIMARY KEY (ID),
    CONSTRAINT UK_USER_USERNAME UNIQUE (USERNAME),
    CONSTRAINT UK_USER_EMAIL    UNIQUE (EMAIL),
    CONSTRAINT CK_USER_STATUS   CHECK (STATUS IN ('ACTIVE', 'INACTIVE', 'BLOCKED'))
);

CREATE INDEX IDX_USER_USERNAME ON "USER" (USERNAME);
CREATE INDEX IDX_USER_EMAIL    ON "USER" (EMAIL);
CREATE INDEX IDX_USER_STATUS   ON "USER" (STATUS);

CREATE SEQUENCE SEQ_USER_HIS START WITH 1 INCREMENT BY 1;

CREATE TABLE USER_HIS (
    ID                  BIGINT          NOT NULL DEFAULT nextval('SEQ_USER_HIS'),
    ORIGINAL_ID         BIGINT          NOT NULL,
    USERNAME            VARCHAR(100)    NOT NULL,
    EMAIL               VARCHAR(150)    NOT NULL,
    PASSWORD_HASH       VARCHAR(255)    NOT NULL,
    FIRST_NAME          VARCHAR(100)    NOT NULL,
    LAST_NAME           VARCHAR(100)    NOT NULL,
    PHONE               VARCHAR(20),
    STATUS              VARCHAR(20)     NOT NULL,
    LAST_LOGIN_DATE     TIMESTAMP,
    ERROR_LOGIN_COUNT   INTEGER         NOT NULL,
    CREATED_BY          VARCHAR(100)    NOT NULL,
    CREATED_DATE        TIMESTAMP       NOT NULL,
    CREATED_IP          VARCHAR(45)     NOT NULL,
    UPDATED_BY          VARCHAR(100),
    UPDATED_DATE        TIMESTAMP,
    UPDATED_IP          VARCHAR(45),
    DML_OPERATION       VARCHAR(10)     NOT NULL,
    DML_BY              VARCHAR(100)    NOT NULL,
    DML_DATE            TIMESTAMP       NOT NULL,
    DML_IP              VARCHAR(45)     NOT NULL,
    CONSTRAINT PK_USER_HIS PRIMARY KEY (ID)
);

CREATE INDEX IDX_USER_HIS_ORIGINAL_ID ON USER_HIS (ORIGINAL_ID);

CREATE OR REPLACE FUNCTION FN_USER_HIS()
RETURNS TRIGGER AS $$
BEGIN
    IF (TG_OP = 'INSERT') THEN
        INSERT INTO USER_HIS (
            ID, ORIGINAL_ID, USERNAME, EMAIL, PASSWORD_HASH, FIRST_NAME, LAST_NAME,
            PHONE, STATUS, LAST_LOGIN_DATE, ERROR_LOGIN_COUNT,
            CREATED_BY, CREATED_DATE, CREATED_IP, UPDATED_BY, UPDATED_DATE, UPDATED_IP,
            DML_OPERATION, DML_BY, DML_DATE, DML_IP
        ) VALUES (
            nextval('SEQ_USER_HIS'), NEW.ID, NEW.USERNAME, NEW.EMAIL, NEW.PASSWORD_HASH, NEW.FIRST_NAME, NEW.LAST_NAME,
            NEW.PHONE, NEW.STATUS, NEW.LAST_LOGIN_DATE, NEW.ERROR_LOGIN_COUNT,
            NEW.CREATED_BY, NEW.CREATED_DATE, NEW.CREATED_IP, NEW.UPDATED_BY, NEW.UPDATED_DATE, NEW.UPDATED_IP,
            'INSERT', NEW.CREATED_BY, NEW.CREATED_DATE, NEW.CREATED_IP
        );
        RETURN NEW;
    ELSIF (TG_OP = 'UPDATE') THEN
        INSERT INTO USER_HIS (
            ID, ORIGINAL_ID, USERNAME, EMAIL, PASSWORD_HASH, FIRST_NAME, LAST_NAME,
            PHONE, STATUS, LAST_LOGIN_DATE, ERROR_LOGIN_COUNT,
            CREATED_BY, CREATED_DATE, CREATED_IP, UPDATED_BY, UPDATED_DATE, UPDATED_IP,
            DML_OPERATION, DML_BY, DML_DATE, DML_IP
        ) VALUES (
            nextval('SEQ_USER_HIS'), NEW.ID, NEW.USERNAME, NEW.EMAIL, NEW.PASSWORD_HASH, NEW.FIRST_NAME, NEW.LAST_NAME,
            NEW.PHONE, NEW.STATUS, NEW.LAST_LOGIN_DATE, NEW.ERROR_LOGIN_COUNT,
            NEW.CREATED_BY, NEW.CREATED_DATE, NEW.CREATED_IP, NEW.UPDATED_BY, NEW.UPDATED_DATE, NEW.UPDATED_IP,
            'UPDATE', NEW.UPDATED_BY, NEW.UPDATED_DATE, NEW.UPDATED_IP
        );
        RETURN NEW;
    ELSIF (TG_OP = 'DELETE') THEN
        INSERT INTO USER_HIS (
            ID, ORIGINAL_ID, USERNAME, EMAIL, PASSWORD_HASH, FIRST_NAME, LAST_NAME,
            PHONE, STATUS, LAST_LOGIN_DATE, ERROR_LOGIN_COUNT,
            CREATED_BY, CREATED_DATE, CREATED_IP, UPDATED_BY, UPDATED_DATE, UPDATED_IP,
            DML_OPERATION, DML_BY, DML_DATE, DML_IP
        ) VALUES (
            nextval('SEQ_USER_HIS'), OLD.ID, OLD.USERNAME, OLD.EMAIL, OLD.PASSWORD_HASH, OLD.FIRST_NAME, OLD.LAST_NAME,
            OLD.PHONE, OLD.STATUS, OLD.LAST_LOGIN_DATE, OLD.ERROR_LOGIN_COUNT,
            OLD.CREATED_BY, OLD.CREATED_DATE, OLD.CREATED_IP, OLD.UPDATED_BY, OLD.UPDATED_DATE, OLD.UPDATED_IP,
            'DELETE', COALESCE(OLD.UPDATED_BY, OLD.CREATED_BY), COALESCE(OLD.UPDATED_DATE, OLD.CREATED_DATE), COALESCE(OLD.UPDATED_IP, OLD.CREATED_IP)
        );
        RETURN OLD;
    END IF;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER TRG_USER_HIS
    AFTER INSERT OR UPDATE OR DELETE ON "USER"
    FOR EACH ROW EXECUTE FUNCTION FN_USER_HIS();


-- ---------------------------------------------------------------
-- ROLE
-- ---------------------------------------------------------------
CREATE SEQUENCE SEQ_ROLE START WITH 1 INCREMENT BY 1;

CREATE TABLE ROLE (
    ID              BIGINT          NOT NULL DEFAULT nextval('SEQ_ROLE'),
    NAME            VARCHAR(100)    NOT NULL,
    DESCRIPTION     VARCHAR(500),
    STATUS          VARCHAR(20)     NOT NULL DEFAULT 'ACTIVE',
    CREATED_BY      VARCHAR(100)    NOT NULL,
    CREATED_DATE    TIMESTAMP       NOT NULL,
    CREATED_IP      VARCHAR(45)     NOT NULL,
    UPDATED_BY      VARCHAR(100),
    UPDATED_DATE    TIMESTAMP,
    UPDATED_IP      VARCHAR(45),
    CONSTRAINT PK_ROLE        PRIMARY KEY (ID),
    CONSTRAINT UK_ROLE_NAME   UNIQUE (NAME),
    CONSTRAINT CK_ROLE_STATUS CHECK (STATUS IN ('ACTIVE', 'INACTIVE'))
);

CREATE INDEX IDX_ROLE_NAME   ON ROLE (NAME);
CREATE INDEX IDX_ROLE_STATUS ON ROLE (STATUS);

CREATE SEQUENCE SEQ_ROLE_HIS START WITH 1 INCREMENT BY 1;

CREATE TABLE ROLE_HIS (
    ID              BIGINT          NOT NULL DEFAULT nextval('SEQ_ROLE_HIS'),
    ORIGINAL_ID     BIGINT          NOT NULL,
    NAME            VARCHAR(100)    NOT NULL,
    DESCRIPTION     VARCHAR(500),
    STATUS          VARCHAR(20)     NOT NULL,
    CREATED_BY      VARCHAR(100)    NOT NULL,
    CREATED_DATE    TIMESTAMP       NOT NULL,
    CREATED_IP      VARCHAR(45)     NOT NULL,
    UPDATED_BY      VARCHAR(100),
    UPDATED_DATE    TIMESTAMP,
    UPDATED_IP      VARCHAR(45),
    DML_OPERATION   VARCHAR(10)     NOT NULL,
    DML_BY          VARCHAR(100)    NOT NULL,
    DML_DATE        TIMESTAMP       NOT NULL,
    DML_IP          VARCHAR(45)     NOT NULL,
    CONSTRAINT PK_ROLE_HIS PRIMARY KEY (ID)
);

CREATE INDEX IDX_ROLE_HIS_ORIGINAL_ID ON ROLE_HIS (ORIGINAL_ID);

CREATE OR REPLACE FUNCTION FN_ROLE_HIS()
RETURNS TRIGGER AS $$
BEGIN
    IF (TG_OP = 'INSERT') THEN
        INSERT INTO ROLE_HIS (
            ID, ORIGINAL_ID, NAME, DESCRIPTION, STATUS,
            CREATED_BY, CREATED_DATE, CREATED_IP, UPDATED_BY, UPDATED_DATE, UPDATED_IP,
            DML_OPERATION, DML_BY, DML_DATE, DML_IP
        ) VALUES (
            nextval('SEQ_ROLE_HIS'), NEW.ID, NEW.NAME, NEW.DESCRIPTION, NEW.STATUS,
            NEW.CREATED_BY, NEW.CREATED_DATE, NEW.CREATED_IP, NEW.UPDATED_BY, NEW.UPDATED_DATE, NEW.UPDATED_IP,
            'INSERT', NEW.CREATED_BY, NEW.CREATED_DATE, NEW.CREATED_IP
        );
        RETURN NEW;
    ELSIF (TG_OP = 'UPDATE') THEN
        INSERT INTO ROLE_HIS (
            ID, ORIGINAL_ID, NAME, DESCRIPTION, STATUS,
            CREATED_BY, CREATED_DATE, CREATED_IP, UPDATED_BY, UPDATED_DATE, UPDATED_IP,
            DML_OPERATION, DML_BY, DML_DATE, DML_IP
        ) VALUES (
            nextval('SEQ_ROLE_HIS'), NEW.ID, NEW.NAME, NEW.DESCRIPTION, NEW.STATUS,
            NEW.CREATED_BY, NEW.CREATED_DATE, NEW.CREATED_IP, NEW.UPDATED_BY, NEW.UPDATED_DATE, NEW.UPDATED_IP,
            'UPDATE', NEW.UPDATED_BY, NEW.UPDATED_DATE, NEW.UPDATED_IP
        );
        RETURN NEW;
    ELSIF (TG_OP = 'DELETE') THEN
        INSERT INTO ROLE_HIS (
            ID, ORIGINAL_ID, NAME, DESCRIPTION, STATUS,
            CREATED_BY, CREATED_DATE, CREATED_IP, UPDATED_BY, UPDATED_DATE, UPDATED_IP,
            DML_OPERATION, DML_BY, DML_DATE, DML_IP
        ) VALUES (
            nextval('SEQ_ROLE_HIS'), OLD.ID, OLD.NAME, OLD.DESCRIPTION, OLD.STATUS,
            OLD.CREATED_BY, OLD.CREATED_DATE, OLD.CREATED_IP, OLD.UPDATED_BY, OLD.UPDATED_DATE, OLD.UPDATED_IP,
            'DELETE', COALESCE(OLD.UPDATED_BY, OLD.CREATED_BY), COALESCE(OLD.UPDATED_DATE, OLD.CREATED_DATE), COALESCE(OLD.UPDATED_IP, OLD.CREATED_IP)
        );
        RETURN OLD;
    END IF;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER TRG_ROLE_HIS
    AFTER INSERT OR UPDATE OR DELETE ON ROLE
    FOR EACH ROW EXECUTE FUNCTION FN_ROLE_HIS();


-- ---------------------------------------------------------------
-- PERMISSION
-- ---------------------------------------------------------------
CREATE SEQUENCE SEQ_PERMISSION START WITH 1 INCREMENT BY 1;

CREATE TABLE PERMISSION (
    ID              BIGINT          NOT NULL DEFAULT nextval('SEQ_PERMISSION'),
    NAME            VARCHAR(100)    NOT NULL,
    DESCRIPTION     VARCHAR(500),
    MODULE          VARCHAR(100)    NOT NULL,
    ACTION          VARCHAR(50)     NOT NULL,
    STATUS          VARCHAR(20)     NOT NULL DEFAULT 'ACTIVE',
    CREATED_BY      VARCHAR(100)    NOT NULL,
    CREATED_DATE    TIMESTAMP       NOT NULL,
    CREATED_IP      VARCHAR(45)     NOT NULL,
    UPDATED_BY      VARCHAR(100),
    UPDATED_DATE    TIMESTAMP,
    UPDATED_IP      VARCHAR(45),
    CONSTRAINT PK_PERMISSION                PRIMARY KEY (ID),
    CONSTRAINT UK_PERMISSION_NAME           UNIQUE (NAME),
    CONSTRAINT UK_PERMISSION_MODULE_ACTION  UNIQUE (MODULE, ACTION),
    CONSTRAINT CK_PERMISSION_STATUS         CHECK (STATUS IN ('ACTIVE', 'INACTIVE')),
    CONSTRAINT CK_PERMISSION_ACTION         CHECK (ACTION IN ('CREATE', 'READ', 'UPDATE', 'DELETE', 'LIST', 'EXPORT', 'IMPORT'))
);

CREATE INDEX IDX_PERMISSION_NAME   ON PERMISSION (NAME);
CREATE INDEX IDX_PERMISSION_MODULE ON PERMISSION (MODULE);
CREATE INDEX IDX_PERMISSION_ACTION ON PERMISSION (ACTION);
CREATE INDEX IDX_PERMISSION_STATUS ON PERMISSION (STATUS);

CREATE SEQUENCE SEQ_PERMISSION_HIS START WITH 1 INCREMENT BY 1;

CREATE TABLE PERMISSION_HIS (
    ID              BIGINT          NOT NULL DEFAULT nextval('SEQ_PERMISSION_HIS'),
    ORIGINAL_ID     BIGINT          NOT NULL,
    NAME            VARCHAR(100)    NOT NULL,
    DESCRIPTION     VARCHAR(500),
    MODULE          VARCHAR(100)    NOT NULL,
    ACTION          VARCHAR(50)     NOT NULL,
    STATUS          VARCHAR(20)     NOT NULL,
    CREATED_BY      VARCHAR(100)    NOT NULL,
    CREATED_DATE    TIMESTAMP       NOT NULL,
    CREATED_IP      VARCHAR(45)     NOT NULL,
    UPDATED_BY      VARCHAR(100),
    UPDATED_DATE    TIMESTAMP,
    UPDATED_IP      VARCHAR(45),
    DML_OPERATION   VARCHAR(10)     NOT NULL,
    DML_BY          VARCHAR(100)    NOT NULL,
    DML_DATE        TIMESTAMP       NOT NULL,
    DML_IP          VARCHAR(45)     NOT NULL,
    CONSTRAINT PK_PERMISSION_HIS PRIMARY KEY (ID)
);

CREATE INDEX IDX_PERMISSION_HIS_ORIGINAL_ID ON PERMISSION_HIS (ORIGINAL_ID);

CREATE OR REPLACE FUNCTION FN_PERMISSION_HIS()
RETURNS TRIGGER AS $$
BEGIN
    IF (TG_OP = 'INSERT') THEN
        INSERT INTO PERMISSION_HIS (
            ID, ORIGINAL_ID, NAME, DESCRIPTION, MODULE, ACTION, STATUS,
            CREATED_BY, CREATED_DATE, CREATED_IP, UPDATED_BY, UPDATED_DATE, UPDATED_IP,
            DML_OPERATION, DML_BY, DML_DATE, DML_IP
        ) VALUES (
            nextval('SEQ_PERMISSION_HIS'), NEW.ID, NEW.NAME, NEW.DESCRIPTION, NEW.MODULE, NEW.ACTION, NEW.STATUS,
            NEW.CREATED_BY, NEW.CREATED_DATE, NEW.CREATED_IP, NEW.UPDATED_BY, NEW.UPDATED_DATE, NEW.UPDATED_IP,
            'INSERT', NEW.CREATED_BY, NEW.CREATED_DATE, NEW.CREATED_IP
        );
        RETURN NEW;
    ELSIF (TG_OP = 'UPDATE') THEN
        INSERT INTO PERMISSION_HIS (
            ID, ORIGINAL_ID, NAME, DESCRIPTION, MODULE, ACTION, STATUS,
            CREATED_BY, CREATED_DATE, CREATED_IP, UPDATED_BY, UPDATED_DATE, UPDATED_IP,
            DML_OPERATION, DML_BY, DML_DATE, DML_IP
        ) VALUES (
            nextval('SEQ_PERMISSION_HIS'), NEW.ID, NEW.NAME, NEW.DESCRIPTION, NEW.MODULE, NEW.ACTION, NEW.STATUS,
            NEW.CREATED_BY, NEW.CREATED_DATE, NEW.CREATED_IP, NEW.UPDATED_BY, NEW.UPDATED_DATE, NEW.UPDATED_IP,
            'UPDATE', NEW.UPDATED_BY, NEW.UPDATED_DATE, NEW.UPDATED_IP
        );
        RETURN NEW;
    ELSIF (TG_OP = 'DELETE') THEN
        INSERT INTO PERMISSION_HIS (
            ID, ORIGINAL_ID, NAME, DESCRIPTION, MODULE, ACTION, STATUS,
            CREATED_BY, CREATED_DATE, CREATED_IP, UPDATED_BY, UPDATED_DATE, UPDATED_IP,
            DML_OPERATION, DML_BY, DML_DATE, DML_IP
        ) VALUES (
            nextval('SEQ_PERMISSION_HIS'), OLD.ID, OLD.NAME, OLD.DESCRIPTION, OLD.MODULE, OLD.ACTION, OLD.STATUS,
            OLD.CREATED_BY, OLD.CREATED_DATE, OLD.CREATED_IP, OLD.UPDATED_BY, OLD.UPDATED_DATE, OLD.UPDATED_IP,
            'DELETE', COALESCE(OLD.UPDATED_BY, OLD.CREATED_BY), COALESCE(OLD.UPDATED_DATE, OLD.CREATED_DATE), COALESCE(OLD.UPDATED_IP, OLD.CREATED_IP)
        );
        RETURN OLD;
    END IF;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER TRG_PERMISSION_HIS
    AFTER INSERT OR UPDATE OR DELETE ON PERMISSION
    FOR EACH ROW EXECUTE FUNCTION FN_PERMISSION_HIS();


-- ---------------------------------------------------------------
-- USER_ROLE
-- ---------------------------------------------------------------
CREATE SEQUENCE SEQ_USER_ROLE START WITH 1 INCREMENT BY 1;

CREATE TABLE USER_ROLE (
    ID              BIGINT          NOT NULL DEFAULT nextval('SEQ_USER_ROLE'),
    USER_ID         BIGINT          NOT NULL,
    ROLE_ID         BIGINT          NOT NULL,
    ASSIGNED_BY     VARCHAR(100)    NOT NULL,
    ASSIGNED_DATE   TIMESTAMP       NOT NULL,
    CREATED_BY      VARCHAR(100)    NOT NULL,
    CREATED_DATE    TIMESTAMP       NOT NULL,
    CREATED_IP      VARCHAR(45)     NOT NULL,
    UPDATED_BY      VARCHAR(100),
    UPDATED_DATE    TIMESTAMP,
    UPDATED_IP      VARCHAR(45),
    CONSTRAINT PK_USER_ROLE             PRIMARY KEY (ID),
    CONSTRAINT UK_USER_ROLE_USER_ROLE   UNIQUE (USER_ID, ROLE_ID),
    CONSTRAINT FK_USER_ROLE_USER        FOREIGN KEY (USER_ID) REFERENCES "USER"(ID),
    CONSTRAINT FK_USER_ROLE_ROLE        FOREIGN KEY (ROLE_ID) REFERENCES ROLE(ID)
);

CREATE INDEX IDX_USER_ROLE_USER_ID ON USER_ROLE (USER_ID);
CREATE INDEX IDX_USER_ROLE_ROLE_ID ON USER_ROLE (ROLE_ID);

CREATE SEQUENCE SEQ_USER_ROLE_HIS START WITH 1 INCREMENT BY 1;

CREATE TABLE USER_ROLE_HIS (
    ID              BIGINT          NOT NULL DEFAULT nextval('SEQ_USER_ROLE_HIS'),
    ORIGINAL_ID     BIGINT          NOT NULL,
    USER_ID         BIGINT          NOT NULL,
    ROLE_ID         BIGINT          NOT NULL,
    ASSIGNED_BY     VARCHAR(100)    NOT NULL,
    ASSIGNED_DATE   TIMESTAMP       NOT NULL,
    CREATED_BY      VARCHAR(100)    NOT NULL,
    CREATED_DATE    TIMESTAMP       NOT NULL,
    CREATED_IP      VARCHAR(45)     NOT NULL,
    UPDATED_BY      VARCHAR(100),
    UPDATED_DATE    TIMESTAMP,
    UPDATED_IP      VARCHAR(45),
    DML_OPERATION   VARCHAR(10)     NOT NULL,
    DML_BY          VARCHAR(100)    NOT NULL,
    DML_DATE        TIMESTAMP       NOT NULL,
    DML_IP          VARCHAR(45)     NOT NULL,
    CONSTRAINT PK_USER_ROLE_HIS PRIMARY KEY (ID)
);

CREATE INDEX IDX_USER_ROLE_HIS_ORIGINAL_ID ON USER_ROLE_HIS (ORIGINAL_ID);

CREATE OR REPLACE FUNCTION FN_USER_ROLE_HIS()
RETURNS TRIGGER AS $$
BEGIN
    IF (TG_OP = 'INSERT') THEN
        INSERT INTO USER_ROLE_HIS (
            ID, ORIGINAL_ID, USER_ID, ROLE_ID, ASSIGNED_BY, ASSIGNED_DATE,
            CREATED_BY, CREATED_DATE, CREATED_IP, UPDATED_BY, UPDATED_DATE, UPDATED_IP,
            DML_OPERATION, DML_BY, DML_DATE, DML_IP
        ) VALUES (
            nextval('SEQ_USER_ROLE_HIS'), NEW.ID, NEW.USER_ID, NEW.ROLE_ID, NEW.ASSIGNED_BY, NEW.ASSIGNED_DATE,
            NEW.CREATED_BY, NEW.CREATED_DATE, NEW.CREATED_IP, NEW.UPDATED_BY, NEW.UPDATED_DATE, NEW.UPDATED_IP,
            'INSERT', NEW.CREATED_BY, NEW.CREATED_DATE, NEW.CREATED_IP
        );
        RETURN NEW;
    ELSIF (TG_OP = 'UPDATE') THEN
        INSERT INTO USER_ROLE_HIS (
            ID, ORIGINAL_ID, USER_ID, ROLE_ID, ASSIGNED_BY, ASSIGNED_DATE,
            CREATED_BY, CREATED_DATE, CREATED_IP, UPDATED_BY, UPDATED_DATE, UPDATED_IP,
            DML_OPERATION, DML_BY, DML_DATE, DML_IP
        ) VALUES (
            nextval('SEQ_USER_ROLE_HIS'), NEW.ID, NEW.USER_ID, NEW.ROLE_ID, NEW.ASSIGNED_BY, NEW.ASSIGNED_DATE,
            NEW.CREATED_BY, NEW.CREATED_DATE, NEW.CREATED_IP, NEW.UPDATED_BY, NEW.UPDATED_DATE, NEW.UPDATED_IP,
            'UPDATE', NEW.UPDATED_BY, NEW.UPDATED_DATE, NEW.UPDATED_IP
        );
        RETURN NEW;
    ELSIF (TG_OP = 'DELETE') THEN
        INSERT INTO USER_ROLE_HIS (
            ID, ORIGINAL_ID, USER_ID, ROLE_ID, ASSIGNED_BY, ASSIGNED_DATE,
            CREATED_BY, CREATED_DATE, CREATED_IP, UPDATED_BY, UPDATED_DATE, UPDATED_IP,
            DML_OPERATION, DML_BY, DML_DATE, DML_IP
        ) VALUES (
            nextval('SEQ_USER_ROLE_HIS'), OLD.ID, OLD.USER_ID, OLD.ROLE_ID, OLD.ASSIGNED_BY, OLD.ASSIGNED_DATE,
            OLD.CREATED_BY, OLD.CREATED_DATE, OLD.CREATED_IP, OLD.UPDATED_BY, OLD.UPDATED_DATE, OLD.UPDATED_IP,
            'DELETE', COALESCE(OLD.UPDATED_BY, OLD.CREATED_BY), COALESCE(OLD.UPDATED_DATE, OLD.CREATED_DATE), COALESCE(OLD.UPDATED_IP, OLD.CREATED_IP)
        );
        RETURN OLD;
    END IF;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER TRG_USER_ROLE_HIS
    AFTER INSERT OR UPDATE OR DELETE ON USER_ROLE
    FOR EACH ROW EXECUTE FUNCTION FN_USER_ROLE_HIS();


-- ---------------------------------------------------------------
-- ROLE_PERMISSION
-- ---------------------------------------------------------------
CREATE SEQUENCE SEQ_ROLE_PERMISSION START WITH 1 INCREMENT BY 1;

CREATE TABLE ROLE_PERMISSION (
    ID              BIGINT          NOT NULL DEFAULT nextval('SEQ_ROLE_PERMISSION'),
    ROLE_ID         BIGINT          NOT NULL,
    PERMISSION_ID   BIGINT          NOT NULL,
    CREATED_BY      VARCHAR(100)    NOT NULL,
    CREATED_DATE    TIMESTAMP       NOT NULL,
    CREATED_IP      VARCHAR(45)     NOT NULL,
    UPDATED_BY      VARCHAR(100),
    UPDATED_DATE    TIMESTAMP,
    UPDATED_IP      VARCHAR(45),
    CONSTRAINT PK_ROLE_PERMISSION                       PRIMARY KEY (ID),
    CONSTRAINT UK_ROLE_PERMISSION_ROLE_PERMISSION       UNIQUE (ROLE_ID, PERMISSION_ID),
    CONSTRAINT FK_ROLE_PERMISSION_ROLE                  FOREIGN KEY (ROLE_ID)       REFERENCES ROLE(ID),
    CONSTRAINT FK_ROLE_PERMISSION_PERMISSION            FOREIGN KEY (PERMISSION_ID) REFERENCES PERMISSION(ID)
);

CREATE INDEX IDX_ROLE_PERMISSION_ROLE_ID       ON ROLE_PERMISSION (ROLE_ID);
CREATE INDEX IDX_ROLE_PERMISSION_PERMISSION_ID ON ROLE_PERMISSION (PERMISSION_ID);

CREATE SEQUENCE SEQ_ROLE_PERMISSION_HIS START WITH 1 INCREMENT BY 1;

CREATE TABLE ROLE_PERMISSION_HIS (
    ID              BIGINT          NOT NULL DEFAULT nextval('SEQ_ROLE_PERMISSION_HIS'),
    ORIGINAL_ID     BIGINT          NOT NULL,
    ROLE_ID         BIGINT          NOT NULL,
    PERMISSION_ID   BIGINT          NOT NULL,
    CREATED_BY      VARCHAR(100)    NOT NULL,
    CREATED_DATE    TIMESTAMP       NOT NULL,
    CREATED_IP      VARCHAR(45)     NOT NULL,
    UPDATED_BY      VARCHAR(100),
    UPDATED_DATE    TIMESTAMP,
    UPDATED_IP      VARCHAR(45),
    DML_OPERATION   VARCHAR(10)     NOT NULL,
    DML_BY          VARCHAR(100)    NOT NULL,
    DML_DATE        TIMESTAMP       NOT NULL,
    DML_IP          VARCHAR(45)     NOT NULL,
    CONSTRAINT PK_ROLE_PERMISSION_HIS PRIMARY KEY (ID)
);

CREATE INDEX IDX_ROLE_PERMISSION_HIS_ORIGINAL_ID ON ROLE_PERMISSION_HIS (ORIGINAL_ID);

CREATE OR REPLACE FUNCTION FN_ROLE_PERMISSION_HIS()
RETURNS TRIGGER AS $$
BEGIN
    IF (TG_OP = 'INSERT') THEN
        INSERT INTO ROLE_PERMISSION_HIS (
            ID, ORIGINAL_ID, ROLE_ID, PERMISSION_ID,
            CREATED_BY, CREATED_DATE, CREATED_IP, UPDATED_BY, UPDATED_DATE, UPDATED_IP,
            DML_OPERATION, DML_BY, DML_DATE, DML_IP
        ) VALUES (
            nextval('SEQ_ROLE_PERMISSION_HIS'), NEW.ID, NEW.ROLE_ID, NEW.PERMISSION_ID,
            NEW.CREATED_BY, NEW.CREATED_DATE, NEW.CREATED_IP, NEW.UPDATED_BY, NEW.UPDATED_DATE, NEW.UPDATED_IP,
            'INSERT', NEW.CREATED_BY, NEW.CREATED_DATE, NEW.CREATED_IP
        );
        RETURN NEW;
    ELSIF (TG_OP = 'UPDATE') THEN
        INSERT INTO ROLE_PERMISSION_HIS (
            ID, ORIGINAL_ID, ROLE_ID, PERMISSION_ID,
            CREATED_BY, CREATED_DATE, CREATED_IP, UPDATED_BY, UPDATED_DATE, UPDATED_IP,
            DML_OPERATION, DML_BY, DML_DATE, DML_IP
        ) VALUES (
            nextval('SEQ_ROLE_PERMISSION_HIS'), NEW.ID, NEW.ROLE_ID, NEW.PERMISSION_ID,
            NEW.CREATED_BY, NEW.CREATED_DATE, NEW.CREATED_IP, NEW.UPDATED_BY, NEW.UPDATED_DATE, NEW.UPDATED_IP,
            'UPDATE', NEW.UPDATED_BY, NEW.UPDATED_DATE, NEW.UPDATED_IP
        );
        RETURN NEW;
    ELSIF (TG_OP = 'DELETE') THEN
        INSERT INTO ROLE_PERMISSION_HIS (
            ID, ORIGINAL_ID, ROLE_ID, PERMISSION_ID,
            CREATED_BY, CREATED_DATE, CREATED_IP, UPDATED_BY, UPDATED_DATE, UPDATED_IP,
            DML_OPERATION, DML_BY, DML_DATE, DML_IP
        ) VALUES (
            nextval('SEQ_ROLE_PERMISSION_HIS'), OLD.ID, OLD.ROLE_ID, OLD.PERMISSION_ID,
            OLD.CREATED_BY, OLD.CREATED_DATE, OLD.CREATED_IP, OLD.UPDATED_BY, OLD.UPDATED_DATE, OLD.UPDATED_IP,
            'DELETE', COALESCE(OLD.UPDATED_BY, OLD.CREATED_BY), COALESCE(OLD.UPDATED_DATE, OLD.CREATED_DATE), COALESCE(OLD.UPDATED_IP, OLD.CREATED_IP)
        );
        RETURN OLD;
    END IF;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER TRG_ROLE_PERMISSION_HIS
    AFTER INSERT OR UPDATE OR DELETE ON ROLE_PERMISSION
    FOR EACH ROW EXECUTE FUNCTION FN_ROLE_PERMISSION_HIS();
